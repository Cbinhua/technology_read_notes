Java常用的集合包括List,Set，以及Map，而List、Set、Map都是接口，其中List和Set接口都继承了Colletion接口，
Java的集合持有的并不是对象本身，而是一个指向对象的引用，集合当中放的全部都是引用。
继承List接口的有：ArrayList、LinkedList、Vector
继承Set接口的有：HashSet、TreeSet
继承Map接口的有：HashMap、TreeMap、HashTable
1、List:有序可重复（ArrayList,LinkedList,Vector）
（1）ArrayList 
     底层：使用数组实现 
     特点：查找效率高，随机访问效率高，增删效率低，非线程安全的
     说明：由于ArrayList底层是有数组实现的，那么也就意味着在内存当中是一个有一个连续的内存空间构成，
     学过数据结构的肯定知道，因为是这种连续，会让访问效率变得非常之高，但也会带来一个问题，当你往中间插入一个元素，
     那么插入的位置之后的元素，都要往后移动，如果后面的元素有很多，这显然会让效率大大降低，那么删除呢？也同样面临同样
     的效率问题，因为当你删除中间的某个元素，位于这个删除的元素之后的位置的所有元素都要往前移动，查询呢？因为随机访问
     效率很高，所以查询的效率非常可观。
     一段用迭代器查询的代码：
     //生成arrayList实例对象    
    ArrayList<String> arrayList = new ArrayList<String>();
    //迭代器方式：  
   Iterator<String> intertor = arrayList.iterator();  
   while(intertor.hasNext()){  
      if(intertor.next().equals("a")){  
          System.out.println("该集合当中存在a元素");     
      }  
    }


  （2）LinkedList
     底层：使用双向循环链表实现 
     特点：查找效率低，随机访问效率低，增删效率高，非线程安全的 
     说明：由于LinkedList底层是由双向循环链表实现的，那么这就意味着，内存当中，它存储的每一个元素的内存空间不是连续的，
     这给查询和访问，带来了不便，但是也存在着极大的好处，就是增删效率远远高于ArrayList,因为学过数据结构的都知道，
     链表的增删只需要修改指针指向就可以了，不会像数组那样每次删除，都需要元素配合进行移动，LinkedList并不需要每个
     元素进行移动
   （3）Vector
    说明：这个集合和ArrayList相似，但是它具有一些集合都不具有的特点，最大的不同之处，它跟枚举有关系。还要很重要的
    一点，Vector是线程安全，因为是线程安全的，所以效率上比ArrayList要低
2.Set集合：无序不可重复
无序不可重复：无序指的是Set集合的排列顺序并不会按照你放入元素的顺序来排列，而是通过某些标准进行排列，不可重复指的
是Set集合是不允许放入相同的元素，也就是相同的对象，对象相同是怎么判断的呢？Set集合是通过两个方法来判断其元素是否一
样，这两个方法就是hashCode()方法和equlas()方法，首先，hashCode()方法返回的是一个哈希值，这个哈希值是由对象在内存
中的地址所形成的，如果两个对象的哈希值不一样，那么这两个对象肯定是不相同的，如果哈希值一样，那么这还不能肯定这两个
对象是否一样，还需要通过equlas()方法比较一下两个对象是否一样，equals()返回true才能说明这两个对象是相同的，所以当
你想把你自定义的类对象放入此集合，最好重写一下hashCode()方法和equals()方法来保证Set集合”无序不可重复”的特点。
（1）HashSet 
     底层：使用哈希表实现 
     特点：非线程安全的，放入对象后，其对象的位置与对象本身的hashCode()方法返回的哈希值有关。判断重不重复，
     是通过对象本身的hashCode()方法和equals()方法决定的，所以当你想把你自定义的类对象放入此集合，最好重写一
     下hashCode()方法和equals()方法。
 （2）TreeSet 
     底层：使用树实现 
     特点：非线程安全的，排序规则是默认使用元素的自然排序，或者根据实现Comparable接口(比较器)的compareTo()方法进
     行排序。判断重不重复也是通过compareTo()方法来完成的，当compareTo()方法返回值为0时，两个对象是相同的。所以
     存入TreeSet集合的对象对应的类一定要实现Comparable接口。
3.Map集合：存储的是键值对
键是唯一的，值可以不唯一。Map的键是一个Set集合，只有这样才可以保证键的唯一性，因为Set集合从不放入重复的元素，这就
保证了键的唯一性。 
(1)HashMap 
    底层：数组和链表的结合体（在数据结构称“链表散列“）  
    特点：非线程安全，当你往HashMap中放入键值对的时候，如果你放入的键是自定义的类，那么其该键值对的位置与键对
    象本身的hashCode()方法返回的哈希值有关。判断重不重复，是通过键对象本身的hashCode()方法和equals()方法决定的，
    所以当你想把你自定义的类对象通过键来放入HashMap集合，最好重写一下这个自定义类的hashCode()方法和equals()方法。
    其实Map主要的特点都是通过键来完成的，所以你只要封装好你的自定义类，就可以保证键值的唯一性。 
 （2）TreeMap 
    底层：使用树实现 
    特点：非线程安全，键是TreeSet集合，排序规则是默认使用元素的自然排序，或者根据实现的Comparable接口(比较器)
    的compareTo()方法进行排序。判断重不重复也是通过compareTo()方法来完成的，当compareTo()方法返回值为0时，两个
    对象是相同的。所以保证唯一性，只需要让键对应的类实现Comparable接口（比较器），并且实现compareTo()方法。所以
    存入TreeMap集合作为键的对象对应的类一定要实现Comparable接口。 而跟TreeSet一样，放入后的排序，以及键的唯一性
    都是通过compareTo()方法完成的。所以如何让自定义的类通过键值放入TreeMap集合，并且保证唯一性，和按照一定规则排
    序，只需要这个自定义类实现Comparable接口(比较器)，实现compareTo()方法即可。例子我就不举了，其实和TreeSet的
    那个例子基本一样。
 （3）HashTable 
    底层：使用哈希表实现的 
    特点：线程安全，基本特点和用法和HashMap相似，性能上稍微差于HashMap,因为HashTable是线程安全的。这个集合我就
    不详细说明了，基本和HashMap类似，唯一不同的是它是线程安全的。

    

    
    




    






  


